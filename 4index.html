<html>
<head>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<style>
.navbar-default {
  background-color: #000;
  color: #fff;
}

.carousel-inner >.item > img {
  width: 100%;
  height: 500px;
}

.carousel-inner >.item >.carousel-caption {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 20px;
  background-color: rgba(0, 0, 0, 0.8);
  color: #fff;
}

.carousel-inner >.item >.carousel-caption h3 {
  margin: 0;
}

.carousel-inner >.item >.carousel-caption p {
  margin: 0;
}

feature-box {
  background-color: #f5f5f5;
  padding: 20px;
  text-align: center;
  margin-bottom: 30px;
}

.feature-box i {
  font-size: 50px;
  color: #333;
  margin-right: 20px;
}

.feature-box h3 {
  font-size: 24px;
  color: #333;
  margin-bottom: 10px;
}

.feature-box p {
  font-size: 14px;
  color: #999;
  margin-bottom: 20px;
}

.row {
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}
</style>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
<script>
// Load the pre-trained word embeddings
const embeddings = {};
fetch('https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder%405.0.0/').then(res => {
  return res.arrayBuffer();
}).then(buffer => {
  const model = await tf.loadGraphModel(new Uint8Array(buffer));
  embeddings = async (sentence) => {
    const embeddings = await model.embed(sentence);
    return embeddings.arraySync();
  };
});

const cosineDistance = (vec1, vec2) => {
  const dot = vec1.reduce((acc, curr, i) => acc + curr * vec2[i], 0);
  const mag1 = Math.sqrt(vec1.reduce((acc, curr) => acc + curr * curr, 0));
  const mag2 = Math.sqrt(vec2.reduce((acc, curr) => acc + curr * curr, 0));
  return dot / (mag1 * mag2);
};

const predictNextWords = async (paragraph, incompleteSentence) => {
  const words = incompleteSentence.toLowerCase().split(' ');
  const searchWords = words.slice(Math.max(words.length - 4, 0));

  // Dictionary of words with similar intents
  const intents = {
    'buy': ['purchase', 'acquire', 'obtain'],
    'eat': ['consume', 'devour', 'ingest'],
    'like': ['enjoy', 'prefer', 'fancy'],
    'go': ['travel', 'move', 'journey'],
    // add more intents and related words here
  };

  // Create regex pattern from search words
  const pattern = searchWords.map(word => `\\b${word}\\b`).join('.*') + '.*';

  // Find examples of sentences that match the pattern
  const examples = paragraph.toLowerCase().split('.').map(sentence => sentence.trim()).filter(sentence => sentence.match(new RegExp(pattern)));

  if (examples.length === 0) {
    return null;
  }

  // Get all words that follow the search words in each example sentence
  const candidates = examples.flatMap(example => {
    const exampleWords = example.split(' ');
    const index = searchWords.reduce((acc, curr) => Math.max(acc, exampleWords.findIndex(word => word === curr)), -1);
    return exampleWords.slice(index + 1);
  }).filter(word => word && word.length > 0);

  if (candidates.length === 0) {
    return null;
  }

  // Find the top 5 words with the smallest cosine distance to the last word
  const searchEmbedding = await embeddings(searchWords[searchWords.length - 1]);
  const predictions = candidates.map(word => {
    const intentWords = [word, ...(intents[word] || [])];
    const embeddings = await Promise.all(intentWords.map(embeddings));
    const distances = embeddings.map(embedding => cosineDistance(searchEmbedding, embedding));
    const maxDistance = Math.max(...distances);
    return { word, distance: maxDistance };
  }).filter(prediction => prediction.distance >= 0.5)
    .sort((a, b) => b.distance - a.distance)
    .slice(0, 10)
    .map(prediction => prediction.word);

  return predictions;
};

// Example usage
try {
  const paragraph = readFile("textconverter.txt");
  const incompleteSentence = "where are you from";
  const nextWords = predictNextWords(paragraph, incompleteSentence);
  if (nextWords) {
    const completedSentence = `${incompleteSentence} ${nextWords.join(' ')}`;
    alert(completedSentence);
  } else{
    tk.flash("Could not predict the next word(s).");
  }
}catch(err){
  alert(err.stack)
}
</script>
</body>
</html>
